package backend

import (
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/nirmalpillai17/cve_tracker/models"
	gl "github.com/nirmalpillai17/cve_tracker/global"
)

type customClient struct {
	url             string
	headers         http.Header
	payloadMain     []byte
	payloadDirector []byte
	httpClient      *http.Client
	waitGroup       *sync.WaitGroup
}

const (
	main int = iota
	director
)

func (cc customClient) getGraphanaData(pl io.Reader, ln int) (dt []byte, err error) {
	req, err := http.NewRequest(http.MethodGet, cc.url, pl)
	if err != nil {
		gl.Cl.Error(err)
		return
	}
	for key, value := range cc.headers {
		req.Header[key] = value
	}
	req.Header.Set("Content-Length", strconv.Itoa(ln))
	resp, err := cc.httpClient.Do(req)
	if err != nil {
		gl.Cl.Error(err)
		return
	}
	gl.Cl.Info("request sent successfully")
	defer resp.Body.Close()
	dt, err = io.ReadAll(resp.Body)
	if err != nil {
		gl.Cl.Error(err)
		return
	}
	return
}

func (cc customClient) getDirectorData(dr string, ch chan map[string]models.Format) {
	defer cc.waitGroup.Done()
	payload, length, err := cc.parsePayload(director, dr)
	if err != nil {
		gl.Cl.Error(err)
		return
	}
	out, err := cc.getGraphanaData(payload, length)
	if err != nil {
		gl.Cl.Error(err)
		return
	}
	saveData(dr, out, ch)
}

func (cc customClient) getFullData(s chan int) (err error) {
	s <- 0
	payload, length, err := cc.parsePayload(main, "")
	if err != nil {
		gl.Cl.Error(err)
		s <- 2
		return
	}
	out, err := cc.getGraphanaData(payload, length)
	if err != nil {
		gl.Cl.Error(err)
		s <- 2
		return
	}
	stream := make(chan map[string]models.Format, 500)
	go exportWorkBook(stream)
	data, err := saveData("CVE Summary", out, stream)
	if err != nil {
		gl.Cl.Error(err)
		s <- 2
		return err
	}
	for _, x := range data.Response {
		for _, y := range x.Hits.HitsInner {
			cc.waitGroup.Add(1)
			go cc.getDirectorData(y.Source.Director, stream)
		}
	}
	cc.waitGroup.Wait()
	close(stream)
	s <- 1
	close(s)
	return nil
}

func (cc customClient) parsePayload(fl int, dr string) (io.Reader, int, error) {
	var payloadStr string
	switch fl {
	case main:
		payloadStr = fmt.Sprintf(string(cc.payloadMain), time.Now().UnixMilli())
		break
	case director:
		payloadStr = fmt.Sprintf(string(cc.payloadDirector), time.Now().UnixMilli(), dr)
		break
	default:
		return nil, 0, errors.New("bad flag")
	}
	return strings.NewReader(payloadStr), len(payloadStr), nil
}

func saveData(dr string, dt []byte, ch chan map[string]models.Format) (models.Format, error) {
	var value models.Format
	if err := json.Unmarshal(dt, &value); err != nil {
		gl.Cl.Error(err)
		return value, err
	}
	ch <- map[string]models.Format{dr: value}
	return value, nil
}
