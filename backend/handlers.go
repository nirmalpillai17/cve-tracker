package backend

import (
	"encoding/json"
	"html/template"
	"io"
	"net/http"
	"os"
	"sync"
	"time"

	gl "github.com/nirmalpillai17/cve_tracker/global"
	"github.com/nirmalpillai17/cve_tracker/models"
)

func refreshData(w http.ResponseWriter, r *http.Request) {
	pm, err := os.ReadFile(gl.Bp + "/" + gl.Cm.PlMain)
	if err != nil {
		gl.Cl.HttpError(w, err, http.StatusInternalServerError)
		return
	}
	pd, err := os.ReadFile(gl.Bp + "/" + gl.Cm.PlDirector)
	if err != nil {
		gl.Cl.HttpError(w, err, http.StatusInternalServerError)
		return
	}
	hd, err := os.ReadFile(gl.Bp + "/" + gl.Cm.HeaderFile)
	if err != nil {
		gl.Cl.HttpError(w, err, http.StatusInternalServerError)
		return
	}
	client := customClient{
		url:             gl.Cm.RequestURL,
		payloadMain:     pm,
		payloadDirector: pd,
		httpClient:      http.DefaultClient,
		waitGroup:       &sync.WaitGroup{},
	}
	if err := json.Unmarshal(hd, &client.headers); err != nil {
		gl.Cl.HttpError(w, err, http.StatusInternalServerError)
		return
	}
	err = client.getFullData()
	if err != nil {
		gl.Cl.HttpError(w, err, http.StatusInternalServerError)
		return
	}
	gl.Cl.Info("Data collected successfully")
	http.Redirect(w, r, "data/", http.StatusPermanentRedirect)
}

func reloadConfig(w http.ResponseWriter, r *http.Request) {
	err := gl.Cm.ReadConfig()
	if err != nil {
		gl.Cl.HttpError(w, err, http.StatusInternalServerError)
		return
	}
	gl.Cl.Info("Config reloaded successfully!")
	http.Redirect(w, r, "data/", http.StatusPermanentRedirect)
}

func viewData(w http.ResponseWriter, r *http.Request) {
	var dirInfo []models.Dir
	tplBytes, err := os.ReadFile(gl.Bp + "/" + gl.Cm.DataHtml)
	if err != nil {
		gl.Cl.HttpError(w, err, http.StatusInternalServerError)
	}
	dirs, err := os.ReadDir(gl.Bp + "/" + gl.Cm.OutDir)
	for _, d := range dirs {
		info, _ := d.Info()
		dirInfo = append(dirInfo, models.Dir{
			LastModified: info.ModTime().Format(time.TimeOnly),
			Date:         info.ModTime().Format(time.DateOnly),
			Name:         info.Name(),
			Ip:           gl.Cm.MachineIP,
			Port:         gl.Cm.ServicePort,
		})
	}
	if err != nil {
		gl.Cl.HttpError(w, err, http.StatusInternalServerError)
	}
	if err != nil {
		gl.Cl.HttpError(w, err, http.StatusInternalServerError)
	}
	tpl, err := template.New("data").Parse(string(tplBytes))
	if err != nil {
		gl.Cl.HttpError(w, err, http.StatusInternalServerError)
	}
	if err = tpl.Execute(w, dirInfo); err != nil {
		gl.Cl.HttpError(w, err, http.StatusInternalServerError)
	}
}

func viewLogs(w http.ResponseWriter, r *http.Request) {
	logs, err := os.OpenFile(
		gl.Bp + "/" + gl.Cm.LogFile, os.O_RDONLY, os.ModeType)
	if err != nil {
		gl.Cl.HttpError(w, err, http.StatusInternalServerError)
	}
	defer logs.Close()
	if _, err = logs.Seek(0, 0); err != nil {
		gl.Cl.HttpError(w, err, http.StatusInternalServerError)
	}
	if _, err = io.Copy(w, logs); err != nil {
		gl.Cl.HttpError(w, err, http.StatusInternalServerError)
	}
	if _, err = logs.Seek(0, 2); err != nil {
		gl.Cl.HttpError(w, err, http.StatusInternalServerError)
	}
}
