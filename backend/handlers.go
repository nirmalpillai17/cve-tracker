package backend

import (
	"encoding/json"
	"fmt"
	"html/template"
	"io"
	"net/http"
	"os"
	"strconv"
	"sync"
	"time"

	"github.com/gorilla/mux"
	gl "github.com/nirmalpillai17/cve_tracker/global"
	"github.com/nirmalpillai17/cve_tracker/models"
)

var pm, pd, hd []byte
var client customClient
var js = models.NewJobStatus(5)

func init() {
	var err error
	pm, err = os.ReadFile(gl.Bp + "/" + gl.Cm.PlMain)
	if err != nil {
		gl.Cl.Error(err)
		return
	}
	pd, err = os.ReadFile(gl.Bp + "/" + gl.Cm.PlDirector)
	if err != nil {
		gl.Cl.Error(err)
		return
	}
	hd, err = os.ReadFile(gl.Bp + "/" + gl.Cm.HeaderFile)
	if err != nil {
		gl.Cl.Error(err)
		return
	}
	client = customClient{
		url:             gl.Cm.RequestURL,
		headers:         http.Header{},
		payloadMain:     pm,
		payloadDirector: pd,
		httpClient:      http.DefaultClient,
		waitGroup:       &sync.WaitGroup{},
	}
	if err := json.Unmarshal(hd, &client.headers); err != nil {
		gl.Cl.Error(err)
		return
	}
}

func disableCache(w http.ResponseWriter) {
	w.Header().Add("cache-control", "no-cache")
	w.Header().Add("pragma", "no-cache")
}

func refreshData(w http.ResponseWriter, r *http.Request) {
	s, id := js.NewJob()
	go client.getFullData(s)
	w.Header().Add("Location", "/grafana/data/refresh_data/"+strconv.Itoa(id))
	w.WriteHeader(http.StatusAccepted)
}

func pollHandler(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	rid, _ := strconv.Atoi(vars["id"])
	if cs, ok := js.GetStatus(rid); ok {
		switch cs {
		case models.Running:
			w.WriteHeader(http.StatusAccepted)
			fmt.Fprint(w, "{ \"status\": \"Collecting data...\" }")
		case models.Finished:
			fmt.Fprint(w, "{ \"status\": \"Data collected Successfully!\" }")
		case models.Failed:
			fmt.Fprint(w, "{ \"status\": \"Something went wrong! Check logs for details.\" }")
		}
	} else {
		w.WriteHeader(http.StatusNotFound)
	}
	w.Header().Set("Content-Type", "application/json")
}

func setCookie(w http.ResponseWriter, r *http.Request) {
	//	setCookieHtml, err := os.ReadFile(gl.Bp + "/" + gl.Cm.CookieHtml)
	// need to add the above stuff to config handler
	//	if err != nil {
	//		gl.Cl.HttpError(w, err, http.StatusInternalServerError)
	//		return
	//	}
	//fmt.Fprint(w, setCookieHtml)
	gl.Cl.WriteMessage("Cookie set successfully!")
	disableCache(w)
	//	http.Redirect(w, r, "/grafana/data/", http.StatusSeeOther)
	w.Header().Add("Location", "https://google.com")
	viewData(w, r)
}

func viewData(w http.ResponseWriter, r *http.Request) {
	var tmplData models.TmplData
	tplBytes, err := os.ReadFile(gl.Bp + "/" + gl.Cm.DataHtml)
	if err != nil {
		gl.Cl.HttpError(w, err, http.StatusInternalServerError)
	}
	dirs, err := os.ReadDir(gl.Bp + "/" + gl.Cm.OutDir)
	if err != nil {
		gl.Cl.HttpError(w, err, http.StatusInternalServerError)
	}
	tmplData.Ip = gl.Cm.MachineIP
	tmplData.Port = gl.Cm.ServicePort
	tmplData.Message = gl.Cl.GetMessage()
	for _, d := range dirs {
		info, _ := d.Info()
		tmplData.Data = append(tmplData.Data, models.Dir{
			LastModified: info.ModTime().Format(time.TimeOnly),
			Date:         info.ModTime().Format(time.DateOnly),
			Name:         info.Name(),
		})
	}
	tpl, err := template.New("data").Parse(string(tplBytes))
	if err != nil {
		gl.Cl.HttpError(w, err, http.StatusInternalServerError)
	}
	if err = tpl.Execute(w, tmplData); err != nil {
		gl.Cl.HttpError(w, err, http.StatusInternalServerError)
	}
	disableCache(w)
	gl.Cl.ResetMessage()
}

func viewLogs(w http.ResponseWriter, r *http.Request) {
	logs, err := os.OpenFile(
		gl.Bp+"/"+gl.Cm.LogFile, os.O_RDONLY, os.ModeType)
	if err != nil {
		gl.Cl.HttpError(w, err, http.StatusInternalServerError)
	}
	defer logs.Close()
	if _, err = logs.Seek(0, 0); err != nil {
		gl.Cl.HttpError(w, err, http.StatusInternalServerError)
	}
	if _, err = io.Copy(w, logs); err != nil {
		gl.Cl.HttpError(w, err, http.StatusInternalServerError)
	}
	if _, err = logs.Seek(0, 2); err != nil {
		gl.Cl.HttpError(w, err, http.StatusInternalServerError)
	}
}
