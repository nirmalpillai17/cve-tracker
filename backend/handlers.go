package backend

import (
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"sync"
)

func refreshData(w http.ResponseWriter, r *http.Request) {
	pm, err := os.ReadFile(bp + "/" + cm.PlMain)
	if err != nil {
		cl.HttpError(w, err, http.StatusInternalServerError)
		return
	}
	pd, err := os.ReadFile(bp + "/" + cm.PlDirector)
	if err != nil {
		cl.HttpError(w, err, http.StatusInternalServerError)
		return
	}
	hd, err := os.ReadFile(bp + "/" + cm.HeaderFile)
	if err != nil {
		cl.HttpError(w, err, http.StatusInternalServerError)
		return
	}
	client := customClient{
		url:             cm.RequestURL,
		payloadMain:     pm,
		payloadDirector: pd,
		httpClient:      http.DefaultClient,
		waitGroup:       &sync.WaitGroup{},
	}
	if err := json.Unmarshal(hd, &client.headers); err != nil {
		cl.HttpError(w, err, http.StatusInternalServerError)
		return
	}
	err = client.getFullData()
	if err != nil {
		cl.HttpError(w, err, http.StatusInternalServerError)
		return
	}
	fmt.Fprint(w, "Data collected successfully!\n")
}

func reloadConfig(w http.ResponseWriter, r *http.Request) {
	err := cm.ReadConfig()
	if err != nil {
		cl.HttpError(w, err, http.StatusInternalServerError)
		return
	}
	fmt.Fprint(w, "Config reloaded successfully!\n")
}

func viewData(w http.ResponseWriter, r *http.Request) {
	fmt.Fprint(w, "This is homehandler")
}

func dashHandler(w http.ResponseWriter, r *http.Request) {
	fmt.Fprint(w, "This is dashhandler")
}
