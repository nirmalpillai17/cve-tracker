package backend

import (
	"encoding/json"
	"html/template"
	"io"
	"net/http"
	"os"
	"sync"
	"time"

	gl "github.com/nirmalpillai17/cve_tracker/global"
	"github.com/nirmalpillai17/cve_tracker/models"
)

const sayhi string = "Hi there!"
var message string = sayhi

func disableCache(w http.ResponseWriter) {
	w.Header().Add("cache-control", "no-cache")
	w.Header().Add("pragma", "no-cache")
}

func writeMessage(s string) {
	message = s
	gl.Cl.Info(s)
}

func refreshData(w http.ResponseWriter, r *http.Request) {
	pm, err := os.ReadFile(gl.Bp + "/" + gl.Cm.PlMain)
	if err != nil {
		gl.Cl.HttpError(w, err, http.StatusInternalServerError)
		return
	}
	pd, err := os.ReadFile(gl.Bp + "/" + gl.Cm.PlDirector)
	if err != nil {
		gl.Cl.HttpError(w, err, http.StatusInternalServerError)
		return
	}
	hd, err := os.ReadFile(gl.Bp + "/" + gl.Cm.HeaderFile)
	if err != nil {
		gl.Cl.HttpError(w, err, http.StatusInternalServerError)
		return
	}
	client := customClient{
		url:             gl.Cm.RequestURL,
		headers:         http.Header{},
		payloadMain:     pm,
		payloadDirector: pd,
		httpClient:      http.DefaultClient,
		waitGroup:       &sync.WaitGroup{},
	}
	if err := json.Unmarshal(hd, &client.headers); err != nil {
		gl.Cl.HttpError(w, err, http.StatusInternalServerError)
		return
	}
	err = client.getFullData()
	if err != nil {
		gl.Cl.HttpError(w, err, http.StatusInternalServerError)
		return
	}
	writeMessage("Data collected successfully!")
	disableCache(w)
	http.Redirect(w, r, "data/", http.StatusPermanentRedirect)
}

func reloadConfig(w http.ResponseWriter, r *http.Request) {
	err := gl.Cm.ReadConfig()
	if err != nil {
		gl.Cl.HttpError(w, err, http.StatusInternalServerError)
		return
	}
	writeMessage("Config reloaded successfully!")
	disableCache(w)
	http.Redirect(w, r, "data/", http.StatusPermanentRedirect)
}

func viewData(w http.ResponseWriter, r *http.Request) {
	var tmplData models.TmplData
	tplBytes, err := os.ReadFile(gl.Bp + "/" + gl.Cm.DataHtml)
	if err != nil {
		gl.Cl.HttpError(w, err, http.StatusInternalServerError)
	}
	dirs, err := os.ReadDir(gl.Bp + "/" + gl.Cm.OutDir)
	tmplData.Ip = gl.Cm.MachineIP
	tmplData.Port = gl.Cm.ServicePort
	tmplData.Message = message
	for _, d := range dirs {
		info, _ := d.Info()
		tmplData.Data = append(tmplData.Data, models.Dir{
			LastModified: info.ModTime().Format(time.TimeOnly),
			Date:         info.ModTime().Format(time.DateOnly),
			Name:         info.Name(),
		})
	}
	if err != nil {
		gl.Cl.HttpError(w, err, http.StatusInternalServerError)
	}
	if err != nil {
		gl.Cl.HttpError(w, err, http.StatusInternalServerError)
	}
	tpl, err := template.New("data").Parse(string(tplBytes))
	if err != nil {
		gl.Cl.HttpError(w, err, http.StatusInternalServerError)
	}
	if err = tpl.Execute(w, tmplData); err != nil {
		gl.Cl.HttpError(w, err, http.StatusInternalServerError)
	}
	message = sayhi
}

func viewLogs(w http.ResponseWriter, r *http.Request) {
	logs, err := os.OpenFile(
		gl.Bp + "/" + gl.Cm.LogFile, os.O_RDONLY, os.ModeType)
	if err != nil {
		gl.Cl.HttpError(w, err, http.StatusInternalServerError)
	}
	defer logs.Close()
	if _, err = logs.Seek(0, 0); err != nil {
		gl.Cl.HttpError(w, err, http.StatusInternalServerError)
	}
	if _, err = io.Copy(w, logs); err != nil {
		gl.Cl.HttpError(w, err, http.StatusInternalServerError)
	}
	if _, err = logs.Seek(0, 2); err != nil {
		gl.Cl.HttpError(w, err, http.StatusInternalServerError)
	}
}
